{"ast":null,"code":"/*\r\n\tISC License\r\n\r\n\tCopyright (c) 2019, Pierre-Louis Despaigne\r\n\r\n\tPermission to use, copy, modify, and/or distribute this software for any\r\n\tpurpose with or without fee is hereby granted, provided that the above\r\n\tcopyright notice and this permission notice appear in all copies.\r\n\r\n\tTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r\n\tWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r\n\tMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r\n\tANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r\n\tWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r\n\tACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r\n\tOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\r\n*/\nvar CID = require('cids');\n\nvar multiH = require('multihashes');\n/**\r\n * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'\r\n * @param {string} hex an hexadecimal value\r\n * @return {Buffer} the resulting Buffer\r\n */\n\n\nvar hexStringToBuffer = function hexStringToBuffer(hex) {\n  var prefix = hex.slice(0, 2);\n  var value = hex.slice(2);\n  var res = '';\n  if (prefix === '0x') res = value;else res = hex;\n  return multiH.fromHexString(res);\n};\n/**\r\n* list of known encoding,\r\n* encoding should be a function that takes a `string` input,\r\n* and return a `Buffer` result\r\n*/\n\n\nvar encodes = {\n  /**\r\n  * @param {string} value\r\n  * @return {Buffer}\r\n  */\n  swarm: function swarm(value) {\n    var multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');\n    return new CID(1, 'swarm-manifest', multihash).buffer;\n  },\n\n  /**\r\n  * @param {string} value\r\n  * @return {Buffer}\r\n  */\n  ipfs: function ipfs(value) {\n    var multihash = multiH.fromB58String(value);\n    return new CID(1, 'dag-pb', multihash).buffer;\n  },\n\n  /**\r\n  * @param {string} value\r\n  * @return {Buffer}\r\n  */\n  utf8: function utf8(value) {\n    return Buffer.from(value, 'utf8');\n  }\n};\n/** \r\n* list of known decoding,\r\n* decoding should be a function that takes a `Buffer` input,\r\n* and return a `string` result\r\n*/\n\nvar decodes = {\n  /**\r\n  * @param {Buffer} value \r\n  */\n  hexMultiHash: function hexMultiHash(value) {\n    var cid = new CID(value);\n    return multiH.decode(cid.multihash).digest.toString('hex');\n  },\n\n  /**\r\n  * @param {Buffer} value \r\n  */\n  b58MultiHash: function b58MultiHash(value) {\n    var cid = new CID(value);\n    return multiH.toB58String(cid.multihash);\n  },\n\n  /**\r\n  * @param {Buffer} value \r\n  */\n  utf8: function utf8(value) {\n    return value.toString('utf8');\n  }\n};\n/**\r\n* list of known encoding/decoding for a given codec,\r\n* `encode` should be chosen among the `encodes` functions\r\n* `decode` should be chosen among the `decodes` functions\r\n*/\n\nvar profiles = {\n  'swarm-ns': {\n    encode: encodes.swarm,\n    decode: decodes.hexMultiHash\n  },\n  'ipfs-ns': {\n    encode: encodes.ipfs,\n    decode: decodes.b58MultiHash\n  },\n  'ipns-ns': {\n    encode: encodes.ipfs,\n    decode: decodes.b58MultiHash\n  },\n  'default': {\n    encode: encodes.utf8,\n    decode: decodes.utf8\n  }\n};\nexports.hexStringToBuffer = hexStringToBuffer;\nexports.profiles = profiles;","map":null,"metadata":{},"sourceType":"script"}